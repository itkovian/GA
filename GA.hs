{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NoMonomorphismRestriction#-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}


-- |GA, a Haskell library for working with genetic algoritms
--
-- Aug. 2011, by Kenneth Hoste
--
-- version: 0.1

module GA 
    ( Entity(..)
    , GAConfig(..)
    --, ShowEntity(..)
--    , evolve
--    , optimal
    {-, evolveWithCheckPointing-}) where

import           Control.Monad (liftM, liftM2)
import           Control.Monad.Trans.Class (lift)
import qualified Control.Monad.Writer as W
import           Data.List (intersperse, sortBy, nub, splitAt)
import           Data.Maybe (catMaybes, fromJust, isJust)
import           Data.Monoid
import           Data.Ord (comparing)
import qualified Data.Text as T
import           Debug.Trace (trace)
import           System.Directory (createDirectoryIfMissing, doesFileExist)
import           System.Random (StdGen, mkStdGen, randoms)

-------------------------------------------------------------------------------
-- For debugging purposes, we will use a Writer, so all actions can be logged
-- FIXME: the below can then be removed. As things are now, we execute in the
-- IO monad for no obvious purpose except to log stuff.
--
-- |Return value with debugging output if debugging is enabled.
dbg :: String -> a -> a
dbg str x = if False
                then trace str x
                else x 

-- |Currify a list of elements into tuples.
currify :: [a] -> [(a,a)]
currify (x:y:xs) = (x,y):currify xs
currify [] = []
currify [_] = error "(currify) ERROR: only one element left?!?"


-- |Configuration for genetic algorithm.
data GAConfig = GAConfig 
              { -- |population size
                popSize :: Int
                -- |size of archive (best entities so far)
              , archiveSize :: Int
                -- |maximum number of generations to evolve
              , maxGenerations :: Int
                -- |fraction of entities generated by crossover (tip: >= 0.80)
              , crossoverRate :: Float
                -- |fraction of entities generated by mutation (tip: <= 0.20)
              , mutationRate :: Float
                -- |parameter for crossover (semantics depend on actual crossover operator)
              , crossoverParam :: Float
                -- |parameter for mutation (semantics depend on actual mutation operator)
              , mutationParam :: Float
                -- |enable/disable built-in checkpointing mechanism
              , withCheckpointing :: Bool
                -- |enable/disable debugging
              , debug :: Bool
              }

-- | A simpe type synonym for the seed.
type Seed = Int


-- Thank you, applicative@#haskell
--
----------------------------------------------------------------------------------
-- |Type class for mutation of entities
class Mutator a where
  -- |Crossover operator: combine two entities into a new entity.
  crossover :: Float -> Int -> a -> a -> Maybe a

  -- | Mutation operator: mutate an entity into a new entity.
  mutation :: Float -> Int -> a -> Maybe a

----------------------------------------------------------------------------------
-- |Type class for entities that represent a candidate solution.
--
-- Single parameters:
--
-- * Data structure representing an entity (a). At the least a should be an
--   instance of Show, Read, Eq and ShowEntity.
--
-- NOTE: To generate random entities, we need a seed. This is
-- taken care of by the GA library, which provides it for each 
-- call to genRandom. The user of GA is free to use whatever
-- data source that he deems fit to fill up these entities.
--
-- NOTE: Similarly, the score function can obviously use any data source
-- from the user's implementation to assign a score to an entity.
--
class (Monad m, Mutator a) => Entity m a where
  -- |Generate a random entity.
  genRandom :: Seed -> m a
  
  -- |Score an entity (lower is better).
  score :: a -> m Double

  -- |Crossover operator: combine two entities into a new entity.
  -- crossover :: Float -> Int -> a -> a -> Maybe a
  
  -- |Mutation operator: mutate an entity into a new entity.
  -- mutation :: Float -> Int -> a -> Maybe a
  

-- |A possibly scored entity.
type ScoredEntity a = (Double, a)


-- |Scored generation (population and archive).
type Generation m a = W.WriterT T.Text m ([a], [ScoredEntity a])

-- |Type class for pretty printing an entity instead of just using the default show implementation.
--class (Monad m) => ShowEntity m a where
-- |Show an entity.
--  showEntity :: m a -> String

-- |Show a scored entity.
--showScoredEntity :: ShowEntity m a => ScoredEntity a -> String
--showScoredEntity (score,e) = "(" ++ show score ++ ", " ++ showEntity e ++ ")"

-- |Show a list of scored entities.
--showScoredEntities :: ShowEntity m a => [ScoredEntity a] -> String
--showScoredEntities es = ("["++) . (++"]") . concat . intersperse "," $ map showScoredEntity es

-- |Initialize: generate initial population.
initPop :: (Entity m a) => Int -> [Int] -> ([Int], m [a])
initPop n seeds = (seeds'', entities)
  where
    (seeds',seeds'')  = splitAt n seeds
    entities = mapM (genRandom) seeds'


-- |Binary tournament selection operator.
tournamentSelection :: [ScoredEntity a] -> Int -> a
tournamentSelection xs seed = 
  let len = length xs
      g = mkStdGen seed
      is = take 2 $ map (flip mod len) $ randoms g
      [(s1,x1),(s2,x2)] = map ((!!) xs) is   
  in if s1 > s2 
         then x1
         else x2

evolutionSeeds :: Int -> Int -> Int -> ([Int], [Int], [Int], [Int])
evolutionSeeds seed cn mn = 
    let seeds = randoms (mkStdGen seed) :: [Int]
        -- generate twice as many crossover/mutation entities as needed, because crossover/mutation can fail
        (crossoverSelectionSeeds,seeds')    = splitAt (2*2*cn) seeds
        (crossoverSeeds   ,seeds'')         = splitAt (2*cn) seeds'
        (mutationSelectionSeeds  ,seeds''') = splitAt (2*mn) seeds''
        (mutationSeeds     ,_)              = splitAt (2*mn) seeds'''
    in (crossoverSelectionSeeds, crossoverSeeds, mutationSelectionSeeds, mutationSeeds)


-- performCrossover :: (Monad m, Entity m a) => Float -> Int -> [Int] -> [Int] -> [ScoredEntity a] -> [a]
performCrossover p count selSeeds seeds es =
    let tuples = currify $ map (tournamentSelection es) selSeeds
    in take count . catMaybes . zipWith ($) (map (uncurry . (crossover p)) seeds) $ tuples

crossEnts' count p seeds = take count . catMaybes . zipWith ($) (map (uncurry . (crossover p)) seeds) 

 
performMutation :: (Monad m, Entity m a) => Float -> Int -> [Int] -> [Int] -> [ScoredEntity a] -> [a]
performMutation p count selSeeds seeds es = 
    take count $ catMaybes $ zipWith ($) (map (mutation p) seeds) $ map (tournamentSelection es) selSeeds 

-- |Function to perform a single evolution step:
--
-- * score all entities
--
-- * combine with best entities so far
--
-- * sort by fitness
--
-- * create new population using crossover/mutation
evolutionStep :: (Monad m, Entity m a) => (Int,Int,Int) -> (Float,Float) -> Generation m a -> (Int,Int) -> Generation m a
evolutionStep (cn,mn,an) (crossPar,mutPar) generation (gi,seed) = do
    (pop, archive) <- lift $ liftM fst $ W.runWriterT generation  -- lift because we need to get hold of the inner monad shizzle

    -- score population
    scoredPop <- lift . sequence $ map (\e -> score e >>= \s -> return (s,e)) pop
        
        -- combine with archive for selection
    let combo = scoredPop `mappend` archive 
        -- split seeds for crossover selection/seeds, mutation selection/seeds
        (crossoverSelectionSeeds, crossoverSeeds, mutationSelectionSeeds, mutationSeeds) = evolutionSeeds seed cn mn

        -- crossover entities
        -- combo :: [ScoredEntity a] ?
        -- tournamentSelection :: ScoredEntity a -> Int -> a
        crossoverEntities = performCrossover crossPar cn crossoverSelectionSeeds crossoverSeeds combo 
        -- crossoverEntities = crossEnts' cn crossPar crossoverSeeds $ currify $ map (tournamentSelection combo) crossoverSelectionSeeds

    generation
{-
        -- mutation entities
        mutSel = map (tournamentSelection combo) mutSelSeeds
        mutEnts = take cn $ catMaybes $ zipWith ($) (map (mutation mutPar) mutSeeds) mutSel
        -- new population: crossovered + mutated entities
        pop' = undefined -- crossEnts ++ mutEnts
        -- new archive: best entities so far
        archive' = take an $ nub $ sortBy (comparing fst) $ combo 
  
    W.tell $ T.unlines [ "  generation " `mappend` (T.pack $ show gi) `mappend` ":" , "" , ""
--                            , "  scored population: " `mappend` (T.pack $ showScoredEntities scoredPop) , "", ""
--                            , "  archive: " `mappend` (T.pack $ showScoredEntities archive'), "", ""
                            , "  archive fitnesses: " `mappend` (T.pack $ show $ map fst archive'), "", ""
                            , "  generated " `mappend` (T.pack $ show (length pop')) `mappend` " entities", "", ""
                            , "============================================================================================="]
    return $ (pop',archive')
-}

-- |Generate file name for checkpoint.
chkptFileName :: GAConfig -> (Int,Int) -> FilePath
chkptFileName cfg (gi,seed) = dbg fn fn
  where
    cfgTxt = (show $ popSize cfg) ++ "-" ++ 
             (show $ archiveSize cfg) ++ "-" ++
             (show $ crossoverRate cfg) ++ "-" ++
             (show $ mutationRate cfg) ++ "-" ++
             (show $ crossoverParam cfg) ++ "-" ++
             (show $ mutationParam cfg)
    fn = "checkpoints/GA-" ++ cfgTxt ++ "-gen" ++ (show gi) ++ "-seed-" ++ (show seed) ++ ".chk"

-- |Try to restore from checkpoint: first checkpoint for which a checkpoint file is found is restored.
{-

restoreFromCheckpoint :: Entity a => GAConfig -> [(Int,Int)] -> IO (Maybe (Int,Generation a))
restoreFromCheckpoint cfg ((gi,seed):genSeeds) = do
                                                  chkptFound <- doesFileExist fn
                                                  if chkptFound 
                                                    then do
                                                          txt <- readFile fn --dbg ("chk for gen. " ++ (show gi) ++ " found") readFile fn
                                                          return $ Just (gi, W.writer $ read txt)
                                                    else restoreFromCheckpoint cfg genSeeds
  where
    fn = chkptFileName cfg (gi,seed)
restoreFromCheckpoint cfg [] = return Nothing
-}


-- |Checkpoint a single generation.
{-
checkpointGen :: (Entity a) => GAConfig -> Int -> Int -> Generation a -> IO()
checkpointGen cfg index seed generation = do
                                           let (pop, archive) = fst $ W.runWriter generation
                                               txt = show $ (pop,archive)
                                               fn = chkptFileName cfg (index,seed)
                                           if False
                                              then putStrLn $ "writing checkpoint for gen " ++ (show index) ++ " to " ++ fn
                                              else return ()
                                           createDirectoryIfMissing True "checkpoints"
                                           writeFile fn txt
-}


-- |Evolution: evaluate generation, (maybe) checkpoint, continue.
-- FIXME: evolution is not an exported function, so the need to pass along the transformation seems superfluous
{-
evolution :: (Entity a) => GAConfig                                  -- ^ configuration for the GA
                        -> Generation a                               -- ^ current generation
                        -> (Generation a -> (Int,Int) -> Generation a) -- ^ transformation function, i.e., the evolutionary step
                        -> [(Int,Int)]                               -- ^ FIXME: clueless
                        -> IO (Generation a)                          -- ^ Resulting generation
evolution cfg generation step ((gi,seed):gss) = do
                                             let --(pop, archive) = fst $ W.runWriter generation
                                                 newPa = step generation (gi,seed)
                                                 (_, archive') = fst $ W.runWriter newPa
                                                 (Just fitness, e) = head archive'
                                             -- checkpoint generation if desired
                                             if (withCheckpointing cfg)
                                               then checkpointGen cfg gi seed newPa
                                               else return () -- skip checkpoint
                                             putStrLn $ "best entity (gen. " ++ show gi ++ "): " ++ (show e) ++ " [fitness: " ++ show fitness ++ "]"
                                             -- check for perfect entity
                                             if (fromJust $ fst $ head archive') == 0.0
                                                then do 
                                                        putStrLn $ "perfect entity found, finished after " ++ show gi ++ " generations!"
                                                        return newPa
                                                else evolution cfg newPa step gss
-- no more gen. indices/seeds => quit
evolution cfg generation _              []    = do 
                                                      putStrLn $ "done evolving!"
                                                      return generation
-}
{-
evolution :: (Entity m a) => GAConfig                                  -- ^ configuration for the GA
                        -> Generation m a                               -- ^ current generation
                        -> (Generation m a -> (Int,Int) -> Generation m a) -- ^ transformation function, i.e., the evolutionary step
                        -> [(Int,Int)]                               -- ^ FIXME: clueless
                        -> Generation m a                               -- ^ Resulting generation
evolution cfg generation step ((gi,seed):gss) = do
    let --(pop, archive) = fst $ W.runWriter generation
        newPa = step generation (gi,seed)
        (_, archive') = fst $ W.runWriter newPa
    (Just fitness, e) <- liftM head archive'
    W.tell $ "best entity (gen. " 
           `mappend` (T.pack $ show gi) 
           `mappend` "): " 
           `mappend` (T.pack $ show e)
           `mappend` " [fitness: "
           `mappend` (T.pack $ show fitness)
           `mappend` "]"
    -- check for perfect entity
    if fitness == 0.0
        then do 
            W.tell $ "perfect entity found, finished after "
                   `mappend` (T.pack $ show gi)
                   `mappend` " generations!"
            newPa
        else evolution cfg newPa step gss

-- | Quit is there are no more generated indices/seeds
evolution _ generation _ []    = do 
    W.tell $ "done evolving!"
    generation

-}


-- |Do the evolution! In this function, checkpointing is enabled
{-
evolve:: (Entity a) => StdGen -> GAConfig -> IO a
evolve g cfg = do
                -- generate list of random integers
                let rs = randoms g :: [Int]

                    -- initial population
                let (rs',pop) = initPop (popSize cfg) rs

                let ps = popSize cfg
                    -- number of entities generated by crossover/mutation
                    cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
                    mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
                    -- archive size
                    aSize = archiveSize cfg
                    -- crossover/mutation parameters
                    crossPar = crossoverParam cfg
                    mutPar = mutationParam cfg
                    --  seeds for evolution
                    seeds = take (maxGenerations cfg) rs'
                    -- seeds per generation
                    genSeeds = zip [0..] seeds
                    -- checkpoint?
                    checkpointing = withCheckpointing cfg
                    -- do the evolution
                restored <- if checkpointing
                               then restoreFromCheckpoint cfg (reverse genSeeds) :: (Entity a) => IO (Maybe (Int,Generation a))
                               else return Nothing
                let (gi',generation') = case restored of
                                            -- restored pop/archive from checkpoint
                                            Just (gi, generation) -> let g' = generation >>= \generation -> do W.tell $ T.unlines ["restored from checkpoint", "", ""]
                                                                                                               return generation
                                                                     in (gi, g')
                                            _                     -> (-1, return $ (pop, []))
                resGeneration <- evolution cfg generation' (evolutionStep (cCnt,mCnt,aSize) (crossPar,mutPar)) (filter ((>gi') . fst) genSeeds)
                
                let (_, resArchive) = fst $ W.runWriter resGeneration
                if null resArchive
                  then error $ "(evolve) empty archive!"
                  else return $ snd $ head resArchive
-}
{-
-- |Do the evolution! In this function, checkpointing is disabled
evolve:: (Entity m a) => StdGen -> GAConfig -> Generation m a
evolve g cfg = do
    -- generate list of random integers
    let rs = randoms g :: [Int]

        -- initial population
    let (rs',pop) = initPop (popSize cfg) rs

    let ps = popSize cfg
        -- number of entities generated by crossover/mutation
        cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
        mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
        -- archive size
        aSize = archiveSize cfg
        -- crossover/mutation parameters
        crossPar = crossoverParam cfg
        mutPar = mutationParam cfg
        --  seeds for evolution
        seeds = take (maxGenerations cfg) rs'
        -- seeds per generation
        genSeeds = zip [0..] seeds
        -- checkpoint?
        checkpointing = withCheckpointing cfg
        -- do the evolution
        (gi', generation') = (-1, return $ (zip (repeat Nothing) pop, []))
     in undefined -- evolution cfg generation' (evolutionStep (cCnt,mCnt,aSize) (crossPar,mutPar)) (filter ((>gi') . fst) genSeeds)
    
optimal :: Generation m a -> m a
optimal resGeneration = 
    let (_, resArchive) = fst $ W.runWriter resGeneration
    in if null resArchive
           then error $ "(evolve) empty archive!"
           else snd $ head resArchive
-} 
