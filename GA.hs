{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}

-- |GA, a Haskell library for working with genetic algoritms
--
-- Aug. 2011, by Kenneth Hoste
--
-- version: 0.1

module GA 
    ( Entity(..)
    , GAConfig(..)
    , ShowEntity(..)
    , evolve
    {-, evolveWithCheckPointing-}) where

import qualified Control.Monad.Writer as W
import           Data.List (intersperse, sortBy, nub, splitAt)
import           Data.Maybe (catMaybes, fromJust, isJust)
import           Data.Monoid
import           Data.Ord (comparing)
import qualified Data.Text as T
import           Debug.Trace (trace)
import           System.Directory (createDirectoryIfMissing, doesFileExist)
import           System.Random (StdGen, mkStdGen, randoms)

-------------------------------------------------------------------------------
-- For debugging purposes, we will use a Writer, so all actions can be logged
-- FIXME: the below can then be removed. As things are now, we execute in the
-- IO monad for no obvious purpose except to log stuff.
--
-- |Return value with debugging output if debugging is enabled.
dbg :: String -> a -> a
dbg str x = if False
                then trace str x
                else x 

-- |Currify a list of elements into tuples.
currify :: [a] -> [(a,a)]
currify (x:y:xs) = (x,y):currify xs
currify [] = []
currify [_] = error "(currify) ERROR: only one element left?!?"


-- |Configuration for genetic algorithm.
data GAConfig = GAConfig 
              { -- |population size
                popSize :: Int
                -- |size of archive (best entities so far)
              , archiveSize :: Int
                -- |maximum number of generations to evolve
              , maxGenerations :: Int
                -- |fraction of entities generated by crossover (tip: >= 0.80)
              , crossoverRate :: Float
                -- |fraction of entities generated by mutation (tip: <= 0.20)
              , mutationRate :: Float
                -- |parameter for crossover (semantics depend on actual crossover operator)
              , crossoverParam :: Float
                -- |parameter for mutation (semantics depend on actual mutation operator)
              , mutationParam :: Float
                -- |enable/disable built-in checkpointing mechanism
              , withCheckpointing :: Bool
                -- |enable/disable debugging
              , debug :: Bool
              }

-- | A simpe type synonym for the seed.
type Seed = Int

----------------------------------------------------------------------------------
-- |Type class for entities that represent a candidate solution.
--
-- Single parameters:
--
-- * Data structure representing an entity (a). At the least a should be an
--   instance of Show, Read, Eq and ShowEntity.
--
-- NOTE: To generate random entities, we need a seed. This is
-- taken care of by the GA library, which provides it for each 
-- call to genRandom. The user of GA is free to use whatever
-- data source that he deems fit to fill up these entities.
--
-- NOTE: Similarly, the score function can obviously use any data source
-- from the user's implementation to assign a score to an entity.
--
class (Eq a, Read a, Show a, ShowEntity a) => Entity a where
  -- |Generate a random entity.
  genRandom :: Seed -> a

  -- |Crossover operator: combine two entities into a new entity.
  crossover :: Float -> Int -> a -> a -> Maybe a
  
  -- |Mutation operator: mutate an entity into a new entity.
  mutation :: Float -> Int -> a -> Maybe a
  
  -- |Score an entity (lower is better).
  score :: a -> Double


-- |A possibly scored entity.
type ScoredEntity a = (Maybe Double, a)

-- |Scored generation (population and archive).
type ScoredGen a = W.Writer T.Text ([ScoredEntity a],[ScoredEntity a])

-- |Type class for pretty printing an entity instead of just using the default show implementation.
class ShowEntity a where
  -- |Show an entity.
  showEntity :: a -> String

-- |Show a scored entity.
showScoredEntity :: ShowEntity a => ScoredEntity a -> String
showScoredEntity (score,e) = "(" ++ show score ++ ", " ++ showEntity e ++ ")"

-- |Show a list of scored entities.
showScoredEntities :: ShowEntity a => [ScoredEntity a] -> String
showScoredEntities es = ("["++) . (++"]") . concat . intersperse "," $ map showScoredEntity es

-- |Initialize: generate initial population.
initPop :: (Entity a) => Int -> [Int] -> ([Int],[a])
initPop n seeds = (seeds'', entities)
  where
    (seeds',seeds'')  = splitAt n seeds
    entities = map (genRandom) seeds'

-- |Score an entity (if it hasn't been already).
scoreEnt :: (Entity a) => ScoredEntity a -> ScoredEntity a
scoreEnt e@(Just _, _) = e
scoreEnt (Nothing,x) = (Just $ score x, x)

-- |Binary tournament selection operator.
tournamentSelection :: [ScoredEntity a] -> Int -> a
tournamentSelection xs seed = if s1 < s2 then x1 else x2
  where
    len = length xs
    g = mkStdGen seed
    is = take 2 $ map (flip mod len) $ randoms g
    [(s1,x1),(s2,x2)] = map ((!!) xs) is

-- |Function to perform a single evolution step:
--
-- * score all entities
--
-- * combine with best entities so far
--
-- * sort by fitness
--
-- * create new population using crossover/mutation
evolutionStep :: (Entity a) => (Int,Int,Int) -> (Float,Float) -> ScoredGen a -> (Int,Int) -> ScoredGen a
evolutionStep (cn,mn,an) (crossPar,mutPar) generation (gi,seed) = 
      do W.tell $ T.unlines [ "  generation " `mappend` (T.pack $ show gi) `mappend` ":" , "" , ""
                            , "  scored population: " `mappend` (T.pack $ showScoredEntities scoredPop) , "", ""
                            , "  archive: " `mappend` (T.pack $ showScoredEntities archive'), "", ""
                            , "  archive fitnesses: " `mappend` (T.pack $ show $ map fst archive'), "", ""
                            , "  generated " `mappend` (T.pack $ show (length pop')) `mappend` " entities", "", ""
                            , "============================================================================================="]
         return $ (pop',archive')
  where
    (pop, archive) = fst $ W.runWriter generation
    -- score population
    scoredPop = map (scoreEnt) pop
    -- combine with archive for selection
    combo = scoredPop ++ archive
    -- split seeds for crossover selection/seeds, mutation selection/seeds
    seeds = randoms (mkStdGen seed) :: [Int]

    -- generate twice as many crossover/mutation entities as needed, because crossover/mutation can fail
    (crossSelSeeds,seeds')   = splitAt (2*2*cn) seeds
    (crossSeeds   ,seeds'')  = splitAt (2*cn) seeds'
    (mutSelSeeds  ,seeds''') = splitAt (2*mn) seeds''
    (mutSeeds     ,_)        = splitAt (2*mn) seeds'''

    -- crossover entities
    crossSel = currify $ map (tournamentSelection combo) crossSelSeeds
    crossEnts = take cn $ catMaybes $ zipWith ($) (map (uncurry . (crossover crossPar)) crossSeeds) crossSel
    -- mutation entities
    mutSel = map (tournamentSelection combo) mutSelSeeds
    mutEnts = take cn $ catMaybes $ zipWith ($) (map (mutation mutPar) mutSeeds) mutSel
    -- new population: crossovered + mutated entities
    pop' = zip (repeat Nothing) $ crossEnts ++ mutEnts
    -- new archive: best entities so far
    archive' = take an $ nub $ sortBy (comparing fst) $ filter (isJust . fst) combo -- FIXME: These should be scored, so the filter is superfluous

-- |Generate file name for checkpoint.
chkptFileName :: GAConfig -> (Int,Int) -> FilePath
chkptFileName cfg (gi,seed) = dbg fn fn
  where
    cfgTxt = (show $ popSize cfg) ++ "-" ++ 
             (show $ archiveSize cfg) ++ "-" ++
             (show $ crossoverRate cfg) ++ "-" ++
             (show $ mutationRate cfg) ++ "-" ++
             (show $ crossoverParam cfg) ++ "-" ++
             (show $ mutationParam cfg)
    fn = "checkpoints/GA-" ++ cfgTxt ++ "-gen" ++ (show gi) ++ "-seed-" ++ (show seed) ++ ".chk"

-- |Try to restore from checkpoint: first checkpoint for which a checkpoint file is found is restored.
{-

restoreFromCheckpoint :: Entity a => GAConfig -> [(Int,Int)] -> IO (Maybe (Int,ScoredGen a))
restoreFromCheckpoint cfg ((gi,seed):genSeeds) = do
                                                  chkptFound <- doesFileExist fn
                                                  if chkptFound 
                                                    then do
                                                          txt <- readFile fn --dbg ("chk for gen. " ++ (show gi) ++ " found") readFile fn
                                                          return $ Just (gi, W.writer $ read txt)
                                                    else restoreFromCheckpoint cfg genSeeds
  where
    fn = chkptFileName cfg (gi,seed)
restoreFromCheckpoint cfg [] = return Nothing
-}


-- |Checkpoint a single generation.
{-
checkpointGen :: (Entity a) => GAConfig -> Int -> Int -> ScoredGen a -> IO()
checkpointGen cfg index seed generation = do
                                           let (pop, archive) = fst $ W.runWriter generation
                                               txt = show $ (pop,archive)
                                               fn = chkptFileName cfg (index,seed)
                                           if False
                                              then putStrLn $ "writing checkpoint for gen " ++ (show index) ++ " to " ++ fn
                                              else return ()
                                           createDirectoryIfMissing True "checkpoints"
                                           writeFile fn txt
-}


-- |Evolution: evaluate generation, (maybe) checkpoint, continue.
-- FIXME: evolution is not an exported function, so the need to pass along the transformation seems superfluous
{-
evolution :: (Entity a) => GAConfig                                  -- ^ configuration for the GA
                        -> ScoredGen a                               -- ^ current generation
                        -> (ScoredGen a -> (Int,Int) -> ScoredGen a) -- ^ transformation function, i.e., the evolutionary step
                        -> [(Int,Int)]                               -- ^ FIXME: clueless
                        -> IO (ScoredGen a)                          -- ^ Resulting generation
evolution cfg generation step ((gi,seed):gss) = do
                                             let --(pop, archive) = fst $ W.runWriter generation
                                                 newPa = step generation (gi,seed)
                                                 (_, archive') = fst $ W.runWriter newPa
                                                 (Just fitness, e) = head archive'
                                             -- checkpoint generation if desired
                                             if (withCheckpointing cfg)
                                               then checkpointGen cfg gi seed newPa
                                               else return () -- skip checkpoint
                                             putStrLn $ "best entity (gen. " ++ show gi ++ "): " ++ (show e) ++ " [fitness: " ++ show fitness ++ "]"
                                             -- check for perfect entity
                                             if (fromJust $ fst $ head archive') == 0.0
                                                then do 
                                                        putStrLn $ "perfect entity found, finished after " ++ show gi ++ " generations!"
                                                        return newPa
                                                else evolution cfg newPa step gss
-- no more gen. indices/seeds => quit
evolution cfg generation _              []    = do 
                                                      putStrLn $ "done evolving!"
                                                      return generation
-}

evolution :: (Entity a) => GAConfig                                  -- ^ configuration for the GA
                        -> ScoredGen a                               -- ^ current generation
                        -> (ScoredGen a -> (Int,Int) -> ScoredGen a) -- ^ transformation function, i.e., the evolutionary step
                        -> [(Int,Int)]                               -- ^ FIXME: clueless
                        -> ScoredGen a                               -- ^ Resulting generation
evolution cfg generation step ((gi,seed):gss) = do
    let --(pop, archive) = fst $ W.runWriter generation
        newPa = step generation (gi,seed)
        (_, archive') = fst $ W.runWriter newPa
        (Just fitness, e) = head archive'
    W.tell $ "best entity (gen. " 
           `mappend` (T.pack $ show gi) 
           `mappend` "): " 
           `mappend` (T.pack $ show e)
           `mappend` " [fitness: "
           `mappend` (T.pack $ show fitness)
           `mappend` "]"
    -- check for perfect entity
    if (fromJust $ fst $ head archive') == 0.0
        then do 
            W.tell $ "perfect entity found, finished after "
                   `mappend` (T.pack $ show gi)
                   `mappend` " generations!"
            newPa
        else evolution cfg newPa step gss

-- | Quit is there are no more generated indices/seeds
evolution _ generation _ []    = do 
    W.tell $ "done evolving!"
    generation




-- |Do the evolution! In this function, checkpointing is enabled
{-
evolve:: (Entity a) => StdGen -> GAConfig -> IO a
evolve g cfg = do
                -- generate list of random integers
                let rs = randoms g :: [Int]

                    -- initial population
                let (rs',pop) = initPop (popSize cfg) rs

                let ps = popSize cfg
                    -- number of entities generated by crossover/mutation
                    cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
                    mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
                    -- archive size
                    aSize = archiveSize cfg
                    -- crossover/mutation parameters
                    crossPar = crossoverParam cfg
                    mutPar = mutationParam cfg
                    --  seeds for evolution
                    seeds = take (maxGenerations cfg) rs'
                    -- seeds per generation
                    genSeeds = zip [0..] seeds
                    -- checkpoint?
                    checkpointing = withCheckpointing cfg
                    -- do the evolution
                restored <- if checkpointing
                               then restoreFromCheckpoint cfg (reverse genSeeds) :: (Entity a) => IO (Maybe (Int,ScoredGen a))
                               else return Nothing
                let (gi',generation') = case restored of
                                            -- restored pop/archive from checkpoint
                                            Just (gi, generation) -> let g' = generation >>= \generation -> do W.tell $ T.unlines ["restored from checkpoint", "", ""]
                                                                                                               return generation
                                                                     in (gi, g')
                                            _                     -> (-1, return $ (zip (repeat Nothing) pop, []))
                resGeneration <- evolution cfg generation' (evolutionStep (cCnt,mCnt,aSize) (crossPar,mutPar)) (filter ((>gi') . fst) genSeeds)
                
                let (_, resArchive) = fst $ W.runWriter resGeneration
                if null resArchive
                  then error $ "(evolve) empty archive!"
                  else return $ snd $ head resArchive
-}

-- |Do the evolution! In this function, checkpointing is disabled
evolve:: (Entity a) => StdGen -> GAConfig -> a
evolve g cfg = do
    -- generate list of random integers
    let rs = randoms g :: [Int]

        -- initial population
    let (rs',pop) = initPop (popSize cfg) rs

    let ps = popSize cfg
        -- number of entities generated by crossover/mutation
        cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
        mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
        -- archive size
        aSize = archiveSize cfg
        -- crossover/mutation parameters
        crossPar = crossoverParam cfg
        mutPar = mutationParam cfg
        --  seeds for evolution
        seeds = take (maxGenerations cfg) rs'
        -- seeds per generation
        genSeeds = zip [0..] seeds
        -- checkpoint?
        checkpointing = withCheckpointing cfg
        -- do the evolution
        (gi', generation') = (-1, return $ (zip (repeat Nothing) pop, []))
        resGeneration = evolution cfg generation' (evolutionStep (cCnt,mCnt,aSize) (crossPar,mutPar)) (filter ((>gi') . fst) genSeeds)
    
    let (_, resArchive) = fst $ W.runWriter resGeneration
    if null resArchive
      then error $ "(evolve) empty archive!"
      else snd $ head resArchive
 
